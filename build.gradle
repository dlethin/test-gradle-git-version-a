buildscript {
    repositories {
    	jcenter()
    }
    dependencies {
    	// If we role our own strategy for nextTag Version
		//classpath 'com.github.zafarkhaja:java-semver:0.9.0'
    }
}

plugins {
  id 'org.ajoberstar.grgit' version '1.6.0'

  // only one of the following
  //id 'org.ajoberstar.release-opinion' version '1.6.0'
  id 'org.ajoberstar.release-base' version '1.6.0'
}

import com.github.zafarkhaja.semver.Version
import org.ajoberstar.gradle.git.release.semver.RebuildVersionStrategy
import org.ajoberstar.gradle.git.release.opinion.Strategies

// for the "all" command
import static org.ajoberstar.gradle.git.release.semver.StrategyUtil.*
import org.ajoberstar.gradle.git.release.semver.ChangeScope
import org.ajoberstar.gradle.git.release.semver.SemVerStrategyState


/**
 * Increments the nearest any version using the specified scope.
 *
 * Jumped through a lot of hoops to reverse engineer howthis works.
 * I wanted to increment off of *any* tag, not just from a "normal" tag
 */
def incrementAnyFromScope(SemVerStrategyState state, ChangeScope scope) {

    //def oldNormal = state.nearestVersion.normal
    def oldAny = state.nearestVersion.any

    println "yo: ${oldAny}"
    //oldAny = Version.forIntegers(1,0,2)

    switch (scope) {
        case ChangeScope.MAJOR:
            return state.copyWith(inferredNormal: oldAny.incrementMajorVersion())
        case ChangeScope.MINOR:
            return state.copyWith(inferredNormal: oldAny.incrementMinorVersion())
        case ChangeScope.PATCH:
            return state.copyWith(inferredNormal: oldAny.incrementPatchVersion())
        default:
        	println("yikes")
            return state
    }
}

release {

	// these are all added by default to the opinionated plugin
	versionStrategy RebuildVersionStrategy.INSTANCE

	def myDevStrategy = Strategies.DEVELOPMENT.copyWith(

        normalStrategy: one(

        	//Strategies.Normal.USE_SCOPE_PROP,
        	closure { state -> incrementAnyFromScope(state, state.scopeFromProp) },
        	closure { state -> 

        		println "currentBranch: ${state.currentBranch.name}"

				// Here is where we have to beef up the logic on
				// on when to run this.        		
        		if (!state.currentBranch.name.equals("develop")) {
        			println "using nearest normal"
		        	return Strategies.Normal.USE_NEAREST_ANY.infer(state)
        		} else {
        			println "skipping using nearest normal"
        			return state
        		}
        	},

        	//Strategies.Normal.useScope(ChangeScope.PATCH)
        	closure { state -> incrementAnyFromScope(state, ChangeScope.PATCH) }
        ),

        enforcePrecedence: false,

        preReleaseStrategy: all(

        	//Strategies.PreRelease.STAGE_FLOAT,
        	closure { state ->

        		println "state: ${state}"
	            def sameNormal = state.inferredNormal == state.nearestVersion.any.normalVersion
	            def nearestAnyPreRelease = state.nearestVersion.any.preReleaseVersion

	            println "sameNormal: ${sameNormal}"
	            println "nearestAnyPreRelease: ${nearestAnyPreRelease}"
	            println "nearestVersion: ${state.nearestVersion}"

	            println "heh: ${nearestAnyPreRelease}.${state.stageFromProp}"

	            if (sameNormal && nearestAnyPreRelease != null && nearestAnyPreRelease > state.stageFromProp) {
	            	println("yo1")
	                state.copyWith(inferredPreRelease: "${nearestAnyPreRelease}.${state.stageFromProp}")
	            } else {
	            	println("yo2")
	                state.copyWith(inferredPreRelease: state.stageFromProp)
	            }

	            state
	        },

        	Strategies.PreRelease.COUNT_COMMITS_SINCE_ANY,
        	Strategies.PreRelease.SHOW_UNCOMMITTED),

        // NOTE -- here's how we can override this to inject buildMetadata (counter) coming from GoCD
        //buildMetadataStrategy: BuildMetadata.COMMIT_ABBREVIATED_ID,
        createTag: false
    )

	versionStrategy myDevStrategy
 	versionStrategy Strategies.PRE_RELEASE
 	versionStrategy Strategies.FINAL

	defaultVersionStrategy = myDevStrategy
}

def getVersionCode(version) {

	int baseCode = 0
	int multiplier = 100

    List<String> empties = (1..3).collect { "0" }

    def versionParts = (version.split(/[^0-9]+/) + empties).
            collect{ it as int }[0..< 3]

    int code = baseCode + versionParts.inject(0) { result, i -> result * multiplier + i.toInteger() };

	return code
}

task(version) << {
	println "versionName: ${version.toString()}"

	Version v = Version.valueOf(version.toString())

	println "versionNormal: ${v.getNormalVersion()}"
	println "versionCode: ${getVersionCode(v.getNormalVersion())}"

}
